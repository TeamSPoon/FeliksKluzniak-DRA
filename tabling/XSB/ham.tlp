/* File:      ham.P
** Author(s): Jiyang Xu
** Contact:   xsb-contact@cs.sunysb.edu
**
** Copyright (C) ECRC 1990
**
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
**
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
**
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id: ham.P,v 1.1.1.1 1998/11/05 17:00:59 sbprolog Exp $
**
*/

% Modified by F.K. @ UTD


/************************************************************************/
% the problem consists in finding a closed path through a graph such
% that all the nodes of the graph are visited once. (Hamiltonian path)
/************************************************************************/

demo :- cycle_ham([a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t], Sol),
	 write(Sol), nl, fail.
demo.

cycle_ham( [X|Y], [X, T|L] ):-
        chain_ham( [X|Y], [], [T|L] ),
        edge( T, X ).		%  the last connect_ion

chain_ham( [X|Y], K, L ):-
        delete_( Z, Y, T ),
        edge( X, Z ),
        chain_ham( [Z|T], [X|K], L ).
chain_ham( [X], L, [X|L] ).

delete_( X, [U|Y], [U|Z] ):-
        delete_( X, Y, Z ).
delete_( X, [X|Y], Y ).

edge( X, Y ):-
        connect_( X, L ),
        el1( Y, L ).

el1( X, [X|_] ).
el1( X, [_|L] ):-
	el1( X, L ).

connect_( a, [b, j, k] ).
connect_( b, [a, c, p] ).
connect_( c, [b, d, l] ).
connect_( d, [c, e, q] ).
connect_( e, [d, f, m] ).
connect_( f, [e, g, r] ).
connect_( g, [f, h, n] ).
connect_( h, [i, g, s] ).
connect_( i, [j, h, o] ).
connect_( j, [a, i, t] ).
connect_( k, [o, l, a] ).
connect_( l, [k, m, c] ).
connect_( m, [l, n, e] ).
connect_( n, [m, o, g] ).
connect_( o, [n, k, i] ).
connect_( p, [b, q, t] ).
connect_( q, [p, r, d] ).
connect_( r, [q, s, f] ).
connect_( s, [r, t, h] ).
connect_( t, [p, s, j] ).

/*-----------------------------------------
	this is another graph example
connect_( 0, [1, 2, 3, 4, 5, 6, 7, 8, 9] ).
connect_( 1, [0, 2, 3, 4, 5, 6, 7, 8, 9] ).
connect_( 2, [0, 1, 3, 4, 5, 6, 7, 8, 9] ).
connect_( 3, [0, 1, 2, 4, 5, 6, 7, 8, 9] ).
connect_( 4, [0, 1, 2, 3, 5, 6, 7, 8, 9] ).
connect_( 5, [0, 1, 2, 3, 4, 6, 7, 8, 9] ).
connect_( 6, [0, 1, 2, 3, 4, 5, 7, 8, 9] ).
connect_( 7, [0, 1, 2, 3, 4, 5, 6, 8, 9] ).
connect_( 8, [0, 1, 2, 3, 4, 5, 6, 7, 9] ).
connect_( 9, [0, 1, 2, 3, 4, 5, 6, 7, 8] ).
-----------------------------------------*/

?- set_flag( print_depth, 100 ), demo.
