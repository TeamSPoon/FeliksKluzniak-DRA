\Chapter{Running a program\label{chap:running}}


%-------------------------------------------------------------------------------
\Section{Loading a program\label{sec:loading}}

Once you have loaded the interpreter into your logic programing system, you
may want to load and run a program in the interpreter. This is done by
writing\\
\ind\prog{prog(~\patt{filename}~).}\progidx{prog}%
\footnote{
  If you are running in Eclipse, and have not imported the module \about{dra}
  (as explained on \Pageref{import-dra}), you must write \prog{dra:prog}
  instead of \prog{prog}.
}\\
\patt{filename} should be the name of the file that contains your program.
If the name is given with no extension, the default extension
\prog{.tlp} will be automatically appended to it.%
\index{default extension (file name)}%
\index{extension of file name!default}\index{file!name!default extension}
If the name should have a different extension, you must type in the entire
name, enclosed in single quotes, e.g.,\\
\ind\prog{prog(~'myfile.pl'~).}\\
Quotes must also be used if the file is not in the current directory and you
are providing an absolute or relative path.

As the file is being read and loaded, directives and queries are interpreted
on-the-fly. Each query is evaluated to give all solutions (i.e., as if the
user kept responding with a semicolon): to avoid that you can use the
built-in predicate \pred{once/1} in the queries.


%-------------------------------------------------------------------------------
\Section{Interacting with a loaded program\label{sec:interacting}}

After the file is loaded (and all the directives and queries it contains are
executed), interactive mode is started.  This is very much like the usual
top-level loop, except that it is the interpreter -- and not the
underlying logic programming system -- that is used to evaluate queries and
directives.

Please note that in the interactive mode one cannot input more than one term
per line.

To just enter interactive mode invoke\\
\ind\prog{top}.\progidx{top}%
\footnote{Again, \prog{dra:top} in Eclipse, if you have not imported
  \about{dra}.}\\
 The interpreter does not allow you to input clauses directly from your
 terminal, but this facility may be useful if you have exited interactive
 mode (see below) or interrupted the execution of the interpreter: the
 program that was most recently loaded is still there.

To exit interactive mode enter the end of file character
(\about{Ctrl-D}),%
\footnote{
  \about{Ctrl-D} appears not to work with tkeclipse.}
or just write\\
\ind\prog{quit.}

You should be aware that loading a program obliterates all traces of
previously loaded programs, including the contents of the answer table.  So
if you are interested in re-running your program from scratch (so that it
does not take advantage of answers that were already tabled), you should load
it again.

Just before the result of a query is reported, the interpreter produces a
printout with statistics accummulated since the previous such printout (or
since the beginning, if this is the first printout during this session with
the interpreted program). The printout looks like
this:\\ \ind\prog{[\patt{K}~steps,~\patt{M}~new~answers~tabled~(\patt{N}~in~all)]}\\ \patt{K},
\patt{M} and \patt{N} are natural numbers. \patt{K} is the number of
evaluated goals, \patt{M} is the number of new additions to the answer table,
and \patt{N} is the current size of the answer table.

Please note that in you might sometimes see new answers tabled in 0 steps:
this may happen when you ask for more results (by typing a semicolon) and the
last goal to be activated has still not completed its task.

When a query succeeds, the bindings of variables should be printed upto a
certain maximum depth.  The default value in the distributed version of the
interpreter is 10.  The maximum depth can be changed from the interpreted
program (or interactively from the top-level) by invoking\\
\ind\prog{set\_print\_depth(~\patt{N}~)}\progidx{set\_print\_depth}\\
where \patt{N} is a positive integer.

Please note that with some Prolog implementations this might not prevent a
loop if the printed term is cyclic (as will often happen for coinductive
programs).

Note also that the foregoing does not apply to invocations of built-in
predicates in the interpreted program.  It is up to the user to apply the
built-in that is appropriate for the host logic programming system.  For
example, in the case of Sicstus, use
\prog{write\_term(~T,~[~max\_depth(~10~)~]~)}, rather than just \prog{write(
  T )}, if you expect the instantiation of \prog{T} to be cyclic.



%-------------------------------------------------------------------------------
\Section{Including other files\label{sec:including}%
\index{including a file}\index{file!inclusion}}

To include files (interactively or from other files) you can use the usual
Prolog syntax:\\
\ind
\prog{:-~[~\patt{file1},~\patt{file2},~\patt{...}~].}\\
The default extension is \prog{.tlp}.%
\index{default extension (file name)}%
\index{extension of file name!default}\index{file!name!default extension}

Please note that \prog{:-~[~\patt{file}~].} is not equivalent to
\prog{prog(~\patt{file}~)}. If the former is used, the contents of the file
are just added to the interpreter's memory. If the latter is used, the
interpreter is (re)initialised before loading the file: all previous
information, including the answer table, disappears.

% PROBABLY UNTRUE:
% It is recommended that these directives be used mostly in the text of a
% program.  All the files that are loaded by an invocation of \pred{prog/1} are
% treated as a single program, and the program is subjected to a number of
% sanity checks.  Files that are included interactively from the top level are
% not checked, and errors such as re-definition of predicates defined in other
% files might lead to unexpected results.
%
