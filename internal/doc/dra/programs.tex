\Chapter{The interpreted programs\label{chap:programs}}



%-------------------------------------------------------------------------------
\Section{Limitations\label{sec:limitations}}

The interpreter does not support full Prolog.  Here are the main limitations
of the interpreted language:
\begin{Enumerate}

\item
  The interpreted program must not contain cuts\index{cut}.  Use of the
  conditional construct\index{conditional construct} is permitted, as is the
  use of \predidx{once/1}.

\item
  The interpreted program must not contain variable literals.  It may contain
  invocations of \predidx{call/1}, but if the argument of \pred{call/1} is
  not properly instantiated at runtime, the results will be undefined.

  In some cases the interpreter can verify that the argument of an occurrence
  of \pred{call/1} cannot be instantiated at run-time, and it will then raise
  a fatal error.  The check is quite conservative, so the absence of such an
  error message does not mean that the program is correct in that respect.

\item
  The repertoire of built-in predicates\index{built-in predicates} recognized
  by the interpreter is somewhat limited.  This is done by design, to
  facilitate porting to different Prolog systems.  The recognized built-ins
  are declared in the file \prog{dra\_builtins.pl}, and new declarations can be
  added as the need arises.  For most built-ins it is a matter of just adding
  another line to the file, but a few might require special treatment by the
  interpreter.
\end{Enumerate}

If those limitations seem too strict, you may in some cases get around them
by separating your program into two layers: see \Secref{sec:support}.


%-------------------------------------------------------------------------------
\Section{The notion of ``support''\label{sec:support}}

The interpreter provides you with an opportunity to divide your program into
two layers: an upper layer which makes use of the special facilities provided
by the interpreter (i.e., tabling and/or coinduction), and a lower layer of
``support'' software that requires only standard Prolog.  This can be useful
for increasing efficiency: the support layer will be compiled just as all
other ``normal'' Prolog programs.  An additional advantage is that the
support layer can use the full range of built-in predicates available in the
host logic programming system.

The interface between the two layers consists of a handful of entry-point
predicates, each of which is  declared by a directive similar to the
following one:\\
\ind\prog{:- support check\_consistency/1.}\progidx{support}\\
Please note that this directive cannot be entered interactively: it must be
included in the text of the upper layer part of your program.

The support declaration means that the metainterpreter should treat the
declared predicate as a built-in, i.e., just let Prolog execute it.

The support layer cannot invoke the upper layer, so there is no need to
declare those predicates in the support layer that are not directly invoked
by the upper layer.

Predicates that are declared as "support" must be defined in other files.  To
compile and load such files, use the following directive in the text of your
program:\\
\ind\prog{:- load\_support(~\patt{filename}~).}\\

In this context, the default extension of the \patt{filename} will be your
logic programming system's default extension for names of files that contain
Prolog code.%
\index{default extension (file name)}%
\index{extension of file name!default}%
\index{file!name!default extension}



%-------------------------------------------------------------------------------
\Section{Directives\label{sec:directives}}

Apart from the support directive and directives for file inclusion (see
\Secref{sec:including}, the interpreter recognizes a number of other
directives, which are listed below.  Any other directive is treated as an
error.
\begin{itemize}

\item [Declarations of tabled predicates]
  To declare a predicate as tabled, use a directive similar to the following:\\
  \ind\prog{:-~tabled~ancestor/2.}\progidx{tabled}\\
  The declaration should precede the definition of the predicate.

\item [Declarations of coinductive predicates]
  To declare a predicate as tabled, use a directive similar to the following:\\
  \ind\prog{:-~coinductive~ancestor/2.}\progidx{coinductive}\\
  The declaration should precede the definition of the predicate.

\item [Declarations of ``entry points'']
  Before execution begins, the program is subjected to a number of useful
  sanity checks.  One of these is a check whether every defined predicates
  is actually called from somewhere (i.e., whether there is no dead code).

  Since it is not unusual for a program to contain a handful of such
  predicates (intended as ``entry points'' that are supposed to be invoked
  from a query), the user can declare them by using a directive similar to
  the following:\\
  \ind\prog{:-~top~p/1,~q/2.}\progidx{top}\\
  The declaration is given only to suppress warnings.  However, it is an
  error for an undefined predicate or a support predicate to be so declared.

\item[Declarations of dynamic predicates]
  To declare a predicate whose clauses are asserted and/or retracted by the
  interpreted program, use\\
  \ind\prog{:-~ dynamic~p/k.}\progidx{dynamic}

\item[Changing the order of results\label{old-first}]
  By default, a goal produces new (i.e., heretofore unknown) results before
  producing old ones (see also \Pageref{new-result}).  To reverse this
  behaviour,  use\\
  \ind\prog{:-~old\_first~p/k}.\progidx{old\_first}\\
  or\\
  \ind{:-~old\_first~all.}

\item[Producing a trace]
  To produce a wallpaper trace of what happens to some chosen predicates, use
  a directive similar to the following:\\
  \ind\prog{:-~trace~p/3,~q/0,~r/1.}\progidx{trace}\\
  If you want to trace everything, use\\
  \ind\prog{:-~trace~all.}\\
  These directives are cumulative.

  All the details of the trace will not be easy to understand for someone who
  does not know the details of the DRA method \cite{guo-gupta-dra}, but you
  can glean some useful information, especially about what new answers are
  added to the table.

\item[Querying the answer table]
To print out subsets of the current answer table, use\\
\ind\prog{:-~answers(~\patt{Goal},~Pattern~).}%
\progidx{answers}\\
where \patt{Goal} and \patt{Pattern} are terms.
This will print all tabled answer that are associated with a variant of the
goal and unifiable with the pattern.

To produce a dump of the entire table, use just\\
\ind\prog{:-~answers.}

\item[Producing a trace]
  To produce a wallpaper trace of what happens to some chosen predicates, use
  a directive similar to the following:\\
  \ind\prog{:-~trace~p/3,~q/0,~r/1.}\progidx{trace}\\
  If you want to trace everything, use\\
  \ind\prog{:-~trace~all.}\\
  These directives are cumulative.

  All the details of the trace will not be easy to understand for someone who
  does not know the details of the DRA method \cite{guo-gupta-dra}, but you
  can glean some useful information, especially about how new answers are
  added to the table.

\end{itemize}


%-------------------------------------------------------------------------------
\Section{Hooks\label{sec:hooks}}

The program may contain clauses that modify the definition of the
interpreter's predicate \pred{essence\_hook/2} (the clauses will be asserted
at the front of the predicate, and will thus override the default definition
for some cases).  The interpreter's default definition is\\
\ind\prog{essence\_hook(~T,~T~).}

This predicate is invoked, in certain contexts, when:
\begin{LightItemize}
  \item
    two terms are about to be compared (either for equality or to check
    whether they are variants of each other);
  \item
    an answer is tabled;
  \item
    an answer is retrieved from the table.
\end{LightItemize}

The primary intended use is to suppress arguments that carry only
administrative information and that may differ in two terms that are
``semantically'' equal or variants of each other.

For example, the presence of\\
\ind\prog{essence\_hook(~p(~A,~B,~\_~),~~p(~A,~B~)~).}\\

will result in \prog{p(~a,~b,~c~)} and \prog{p(~a,~b,~d~)} being treated as
identical, as each of them will be translated to \prog{p(~a,~b~)} before
comparison.

\begin{Warning}
This facility should be used with the utmost caution, as it may drastically
affect the semantics of the interpreted program in a fashion that would be
hard to understand for someone who does not understand the details of the
interpreter.
\end{Warning}
